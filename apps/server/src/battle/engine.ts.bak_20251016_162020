/** Battle Engine — estável com initBattle()
 *  - Regras:
 *    • início: P1 ganha 1 energia (arranque)
 *    • passTurn: próximo jogador ganha 1 energia por personagem vivo
 *    • 1 ação por personagem por turno
 */

export type Color = "B" | "R" | "G" | "Y";
export type Cost = Partial<Record<Color, number>>;
export type SkillKind = "attack" | "heal" | "buff" | "shield" | "control" | "damage";

export interface Skill {
  id: string;
  name: string;
  kind: SkillKind;
  cost: Cost;
  power: number;
}

export interface CharacterState {
  id: string;
  name: string;
  role: "adc" | "tank" | "mago" | "assassino";
  hp: number;
  maxHp: number;
  skills: Skill[];
  alive: boolean;
}

export interface PlayerState {
  id: string;
  name: string;
  characters: CharacterState[];
}

export type EnergyPool = Partial<Record<Color, number>>;

export interface BattleState {
  id: string;
  turn: number;
  currentPlayerId: string;
  players: PlayerState[];
  energy: Record<string, EnergyPool>;
  _usedChars?: Set<string>; // controle de 1 ação por personagem/turno
}

export function rid(): string {
  return Math.random().toString(36).slice(2, 10);
}

export function canPay(pool: EnergyPool, cost: Cost): boolean {
  return Object.entries(cost ?? {}).every(([c, q]) => (pool[c as Color] ?? 0) >= (q ?? 0));
}

export function consumeEnergy(pool: EnergyPool, cost: Cost) {
  Object.entries(cost ?? {}).forEach(([c, q]) => {
    const k = c as Color;
    pool[k] = Math.max(0, (pool[k] ?? 0) - (q ?? 0));
  });
}

export function grantRandomEnergy(pool: EnergyPool, n = 1) {
  const colors: Color[] = ["B", "R", "G", "Y"];
  for (let i = 0; i < n; i++) {
    const c = colors[Math.floor(Math.random() * colors.length)];
    pool[c] = (pool[c] ?? 0) + 1;
  }
}

// Skills básicas
const SKILLS: Skill[] = [
  { id: "strike",   name: "Golpe",   kind: "attack", cost: { B: 1 }, power: 25 },
  { id: "fireball", name: "Fireball",kind: "attack", cost: { R: 2 }, power: 40 },
  { id: "heal",     name: "Cura",    kind: "heal",   cost: { G: 1 }, power: 20 },
  { id: "shield",   name: "Escudo",  kind: "shield", cost: { Y: 1 }, power:  0 },
];

function cloneSkills(): Skill[] {
  return SKILLS.map(s => ({ ...s, cost: { ...s.cost } }));
}

/** Cria a batalha inicial e aplica o arranque (P1 ganha 1 energia). */
export function initBattle(): BattleState {
  const makeChar = (name: string, role: CharacterState["role"], idx: number): CharacterState => ({
    id: rid() + "_c" + idx,
    name, role,
    hp: 100, maxHp: 100,
    skills: cloneSkills(),
    alive: true,
  });

  const battle: BattleState = {
    id: rid(),
    turn: 1,
    currentPlayerId: "P1",
    players: [
      {
        id: "P1",
        name: "Jogador 1",
        characters: [
          makeChar("Raven",  "assassino", 1),
          makeChar("Boreal", "tank",      2),
          makeChar("Lyra",   "mago",      3),
        ],
      },
      {
        id: "P2",
        name: "Jogador 2",
        characters: [
          makeChar("Kai", "adc",       1),
          makeChar("Nox", "assassino", 2),
          makeChar("Oris","mago",      3),
        ],
      },
    ],
    energy: {
      P1: { B: 0, R: 0, G: 0, Y: 0 },
      P2: { B: 0, R: 0, G: 0, Y: 0 },
    },
    _usedChars: new Set<string>(),
  };

  // Arranque: P1 ganha 1 energia (primeiro turno começa com 1)
  grantRandomEnergy(battle.energy["P1"], 1);
  return battle;
}

/** Aplica uma ação. Garante 1 ação por personagem no turno. */
export function declareAction(battle: BattleState, act: {
  source: { playerId: string; charId: string };
  target: { playerId: string; charId: string };
  skillId: string;
}) {
  const results: any[] = [];

  // trava por personagem
  battle._usedChars = battle._usedChars || new Set<string>();
  const srcKey = `${act.source.playerId}:${act.source.charId}`;
  if (battle._usedChars.has(srcKey)) {
    results.push({ ok: false, reason: "Esse personagem já agiu neste turno!" });
    return results;
  }

  const srcP = battle.players.find(p => p.id === act.source.playerId);
  const tgtP = battle.players.find(p => p.id === act.target.playerId);
  const src = srcP?.characters.find(c => c.id === act.source.charId);
  const tgt = tgtP?.characters.find(c => c.id === act.target.charId);

  if (!src || !tgt || !src.alive || !tgt.alive) {
    results.push({ ok: false, reason: "Personagem inválido ou morto" });
    return results;
  }

  const skill = src.skills.find(s => s.id === act.skillId);
  if (!skill) {
    results.push({ ok: false, reason: "Skill inválida" });
    return results;
  }

  // alvo aliado/inimigo
  const friendly = act.source.playerId === act.target.playerId;
  const healingKinds: SkillKind[] = ["heal", "buff", "shield"];
  const offensiveKinds: SkillKind[] = ["attack", "control", "damage"];

  if (healingKinds.includes(skill.kind) && !friendly) {
    results.push({ ok: false, reason: "Skill de cura/buff só em aliados" });
    return results;
  }
  if (offensiveKinds.includes(skill.kind) && friendly) {
    results.push({ ok: false, reason: "Skill ofensiva só em inimigos" });
    return results;
  }

  // custo
  const pool = battle.energy[act.source.playerId] || {};
  if (!canPay(pool, skill.cost)) {
    results.push({ ok: false, reason: "Energia insuficiente" });
    return results;
  }

  // consome e aplica
  consumeEnergy(pool, skill.cost);
  battle._usedChars.add(srcKey);

  if (offensiveKinds.includes(skill.kind)) {
    tgt.hp = Math.max(0, tgt.hp - skill.power);
    if (tgt.hp === 0) tgt.alive = false;
    results.push({ ok: true, type: "damage", skill: skill.id, amount: skill.power, target: tgt.id });
  } else if (healingKinds.includes(skill.kind)) {
    tgt.hp = Math.min(tgt.maxHp, tgt.hp + skill.power);
    results.push({ ok: true, type: "heal", skill: skill.id, amount: skill.power, target: tgt.id });
  } else {
    results.push({ ok: true, type: "none" });
  }

  return results;
}

/** Alterna jogador, incrementa turno e dá energia ao próximo (vivos do próximo) */
export function passTurn(battle: BattleState) {
  const current = battle.currentPlayerId;
  const next = battle.players.find(p => p.id !== current)?.id || current;

  battle.turn += 1;
  battle.currentPlayerId = next;
  battle._usedChars = new Set<string>();

  const nextPlayer = battle.players.find(p => p.id === next);
  const aliveCount = (nextPlayer?.characters || []).filter(c => c.alive).length;
  const pool = battle.energy[next] || (battle.energy[next] = {});
  for (let i = 0; i < aliveCount; i++) grantRandomEnergy(pool, 1);

  return battle;
}
